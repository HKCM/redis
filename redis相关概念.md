# 相关概念

<!-- TOC -->
* [相关概念](#相关概念)
  * [持久化](#持久化)
    * [RDB](#rdb)
    * [AOF](#aof)
  * [缓存](#缓存)
    * [缓存更新策略](#缓存更新策略)
    * [内存淘汰策略](#内存淘汰策略)
    * [缓存穿透](#缓存穿透)
    * [缓存雪崩](#缓存雪崩)
    * [缓存击穿](#缓存击穿)
    * [双写一致性](#双写一致性)
  * [主从模式](#主从模式)
    * [主从全量同步原理](#主从全量同步原理)
    * [主从增量同步原理](#主从增量同步原理)
    * [优化同步效率](#优化同步效率)
  * [哨兵模式](#哨兵模式)
    * [Redis哨兵的功能:](#redis哨兵的功能-)
    * [监测机制](#监测机制)
    * [选举规则](#选举规则)
    * [切换规则](#切换规则)
<!-- TOC -->

## 持久化

### RDB
bgsave：开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。
fork采用的是copy-on-write技术：
- 当主进程执行读操作时，访问共享内存；
- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。
- 可能导致内存使用量增加

### AOF

AOF全称为Append Only File(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。

因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个ky的多次写操作，但只有最后一次写操作才有意义。

通过执行`bgrewriteaof`命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

## 缓存

### 缓存更新策略

- **内存淘汰：** redis自动进行，当redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)
- **超时剔除：** 当给redis设置了过期时间ttl之后，redis会将超时的数据进行删除
- **主动更新：** 可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

### 内存淘汰策略

1. noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键
2. allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键
3. volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
4. allkeys-random：加入键的时候如果过限，从所有key随机删除
5. volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐
6. volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
7. volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
8. allkeys-lfu：从所有键中驱逐使用频率最少的键

### 缓存穿透

缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

解决方案：
1. 缓存null值: 实现简单,维护方便,额外的内存消耗,可能造成短期的不一致
2. 布隆过滤: 内存占用较少,没有多余key,实现复杂,存在误判可能
3. 增强id的复杂度，避免被猜测id规律
4. 做好数据的基础格式校验
5. 加强用户权限校验
6. 做好热点参数的限流

### 缓存雪崩

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：
1. 给不同的Key的TTL添加随机值
2. 利用Redis集群提高服务的可用性
3. 给缓存业务添加降级限流策略
4. 给业务添加多级缓存

### 缓存击穿

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

常见的解决方案有两种：
- 互斥锁：采用tryLock方法 + double check来
- 逻辑过期：把过期时间设置在 redis的value中通过业务逻辑判断是否过期，如果过期则通过新的子线程去数据库查询更新

方案对比：

互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响

逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦

### 双写一致性

- 策略1：先更新缓存，再更新数据库 如果只有缓存更新成功，会造成脏数据
- 策略2：先更新数据库，再更新缓存 多线程下，A更新数据库4,B更新数据库5, B更新缓存5, A更新缓存4
- 策略3：先删除缓存，再更新数据库 多线程下，A删除缓存,B读取缓存失败, B从数据库读取并更新缓存, A更新数据库（再删除一次，延迟双删）
- 策略4：先更新数据库，再删除缓存 A更新数据库完数据库后，再删除一次，延迟双删



## 主从模式

### 主从全量同步原理

情况出现在从节点第一次连接主节点

1. 从节点请求数据同步，声明自己的`replication id`和`offset`
2. 主节点检查`replication id`是否第一次同步，如果是第一次，则返回版本信息，从节点保存信息
3. 主节点执行`bgsave`生成RDB文件并发送给从节点
4. 从节点清空本地数据，并加载主节点的RDB文件
5. 于此同时主节点将新的数据的命令记录到`repl_backlog`内存缓冲区中
6. 将`repl_backlog`发送到从节点，完成全量数据同步

### 主从增量同步原理

情况出现在从节点宕机之后，重新连接主节点

`repl_backlog`是一个环，从节点一直在追主节点，如果从节点落后一圈那么增量同步会失败，就需要做全量同步

1. 从节点请求数据同步，声明自己的`replication id`和`offset`
2. 主节点检查`replication id`是否第一次同步，因为`replication id`相同说明不是第一次连接
3. 主节点通过从节点的`offset`定位日志偏移量，只发送`repl_backlog`在`offset`之后的数据


### 优化同步效率

1. 在master中配置repl-diskless-sync yes启用无磁盘复制,避免全量同步时的磁盘IO.
2. 不要让Redis节点占满所有内存，因为RDB需要用到内存
3. 提高`repl_backlog` 大小，发现故障尽快恢复
4. 限制主节点master上的从节点数量，使用主-从-从链式模式

## 哨兵模式

Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。

### Redis哨兵的功能:

- 监控：Sentinel会不断检查您的master和slave 是否按预期工作
- 自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主
- 通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端

### 监测机制

Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：
- 主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。
- 客观下线：若超过指定数量（quorum)的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。

### 选举规则

- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds*10)则会排除该 slave节点
- 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举
- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高

### 切换规则

- sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master
- sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。
- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点